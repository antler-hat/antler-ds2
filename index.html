<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Drum Synth + Sequencer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono&display=swap');
    </style>
    <style>
        :root {
            --space-base: 15px;
            --space-sm: 10px;
            --space-lg: 20px;
            --grey-medium: #555555;
            --grey-light: #cccccc;
            --grey-dark: #333333;
            --grey-darker: #222222;
            --module-bg: #151515;
            --accent-color: #ffffff;
            --accent-glow: rgba(255, 255, 255, 0.5);
            --red-off: #440000;
            --red-on: #ff0000;
            --red-glow: rgba(255, 0, 0, 0.7);
            --indicator-off: #444444;
            --indicator-on: var(--accent-color);
            --indicator-glow: var(--accent-glow);
        }

        html {
            font-size: 10px;
        }
        body {
            margin: 0;
            padding-bottom: 50px; /* Add padding for sequencer */
            background-color: black;
            color: white;
            font-family: "Space Mono", sans-serif;
            display: flex;
            flex-direction: column; /* Stack synth and sequencer */
            align-items: center; /* Center content */
            min-height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            overflow-x: auto;
            font-size: 12px;
            letter-spacing: .1em;
        }
        body.dragging {
            cursor: ns-resize; /* Cursor during knob drag */
        }

        h1 {
            font-size: 15px;
            color: var(--grey-light);
            text-align: center;
            width: 100%;
            letter-spacing: 0.2em;
        }
         h2 {
            font-size: 15px;
            margin: 0;
            color: var(--grey-light);
            text-align: center;
            width: 100%;
         }


        .drum-machine-panel {
            display: grid;
            grid-template-columns: repeat(5, auto);
            gap: var(--space-sm) var(--space-sm);
            min-width: 750px;
            width: max-content;
            border-radius: 8px;
            margin-top: 20px;
            margin-bottom: var(--space-lg); /* Space before sequencer */
            /* Add grid row definition for header */
            grid-template-rows: auto 1fr;
        }

        .header-area {
             grid-column: 1 / span 5;
             grid-row: 1; /* Explicitly place header in first row */
             margin-bottom: var(--space-sm);
        }

        .module {
            grid-row: 2; /* Modules go in the second row */
            padding: var(--space-base);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            min-width: 140px;
            background-color: var(--module-bg);
            border-radius: 5px;
            position: relative;
        }

        .indicator-light {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 10px;
            height: 10px;
            background-color: var(--red-off);
            border-radius: 50%;
            border: 1px solid #222;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.6);
            transition: background-color 0.05s ease-out, box-shadow 0.05s ease-out;
        }

        .indicator-light.active {
            background-color: var(--red-on);
            box-shadow: 0 0 8px var(--red-glow), inset 0 0 3px rgba(255, 200, 200, 0.5);
        }

        .control-grid {
             display: grid;
             grid-template-columns: 1fr 1fr;
             gap: var(--space-base);
             width: 100%;
        }
         .adsr-grid {
             display: grid;
             grid-template-columns: repeat(4, 1fr);
             gap: var(--space-base);
             width: 100%;
             grid-column: 1 / span 2;
         }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 100%;
            height: 70px;
            justify-content: flex-start;
            position: relative;
        }

        label {
            text-transform: uppercase;
            color: #bbb;
            line-height: 1rem;
            height: 1rem;
            margin-bottom: 2px;
            font-size: 10px;
        }

        .waveform-label {
            font-size: 16px;
            height: auto;
        }

        .knob {
            width: 35px;
            height: 35px;
            background-color: #282828;
            border: 1px solid #555;
            border-radius: 50%;
            position: relative;
            cursor: ns-resize;
            outline: none;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            margin-bottom: 2px;
        }

        .knob:before {
            content: '';
            position: absolute;
            width: 2px;
            height: 10px;
            background-color: #eee;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            transform-origin: 50% 13.5px;
        }

        .knob:focus {
            box-shadow: 0 0 0 2px white;
        }

        .knob-value-display {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8em;
            background: black;
            border-radius: 2.5px;
            min-width: 30px;
            text-align: center;
            display: none;
            position: absolute;
            bottom: -1.2em;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            padding: 1px 3px;
        }

        .control-group:has(.knob:focus) .knob-value-display,
        .control-group.interacting .knob-value-display {
             display: inline-block;
        }
         .control-group:has(.knob[data-steps]:focus) .knob-value-display,
         .control-group.interacting:has(.knob[data-steps]) .knob-value-display {
              display: none;
         }

        #effects-master-module {
            grid-template-rows: auto repeat(4, auto);
            gap: var(--space-lg);
            align-items: start;
        }
         #effects-master-module h2 {
             grid-column: 1 / span 2;
         }

         .effects-control-row {
             display: grid;
             grid-template-columns: 1fr 1fr;
             gap: var(--space-sm);
             width: 100%;
             align-items: start;
         }

         /* Specific Grid placements within the panel */
         #voice-module-0 { grid-column: 1; grid-row: 2; }
         #voice-module-1 { grid-column: 2; grid-row: 2; }
         #voice-module-2 { grid-column: 3; grid-row: 2; }
         #voice-module-3 { grid-column: 4; grid-row: 2; }
         #effects-master-module { grid-column: 5; grid-row: 2;}

        /* --- Sequencer Styles --- */
        .sequencer-panel {
            grid-column: 1 / -1;
            padding: var(--space-lg);
            background-color: var(--module-bg);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-lg);
        }

        .sequencer-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: var(--space-lg);
            width: 100%;
        }

        .seq-button {
            padding: var(--space-sm) var(--space-base);
            font-family: "Space Mono", sans-serif;
            font-size: 18px;
            background-color: var(--module-bg);
            color: var(--grey-light);
            border: 0;
            border-radius: 4px;
            cursor: pointer;
            height: 30px;
            width: 30px;
            text-align: center;
            padding: 0;
        }
        .seq-button:hover {
            background-color: var(--grey-dark);
        }
        .seq-button:active {
            background-color: var(--grey-darker);
            box-shadow: inset 0 0 4px rgba(0,0,0,0.5);
        }
        .seq-button.playing {
             background-color: var(--accent-color);
             color: black;
             box-shadow: 0 0 8px var(--accent-glow);
        }
         .seq-button.playing:hover {
             background-color: var(--indicator-glow);
         }

        .tempo-control {
             display: flex;
             align-items: center;
             gap: var(--space-sm);
        }

        .tempo-label {
            font-size: 10px;
            text-transform: uppercase;
            color: #bbb;
        }

        .tempo-input {
            font-family: "Space Mono", sans-serif;
            font-size: 14px;
            background-color: #000;
            color: var(--accent-color);
            border: 1px solid var(--grey-medium);
            border-radius: 3px;
            padding: 5px;
            width: 50px; /* Fixed width */
            text-align: center;
            appearance: textfield; /* Remove spinners */
            -moz-appearance: textfield;
        }
        .tempo-input::-webkit-inner-spin-button,
        .tempo-input::-webkit-outer-spin-button {
          -webkit-appearance: none;
          margin: 0;
        }
        .tempo-input:focus {
             outline: none;
             box-shadow: 0 0 0 2px var(--accent-color);
        }


        .sequencer-grid-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px; /* Gap between indicators and grid */
            width: 100%;
            overflow-x: auto; /* Allow horizontal scroll if needed */
            padding: 5px 0;
        }

        .step-indicator-row {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 4px; /* Match button gap */
            width: calc(100% - 20px); /* Adjust width to align roughly */
            max-width: 600px; /* Max width for indicators */
            margin: 0 auto; /* Center indicators */
            margin-bottom: 8px; /* Space below indicators */
        }

        .step-indicator {
            display: flex;
            justify-content: center;
        }

        .step-indicator:before {
            content: "";
            display: block;
            border-radius: 12px;
            height: 10px;
            width: 10px;
            background-color: var(--red-off);
        }
        .step-indicator.active:before {
            background-color: var(--red-on);
            box-shadow: 0 0 8px var(--red-glow), inset 0 0 3px rgba(255, 200, 200, 0.5);
        }

        .sequencer-grid {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 4px;
            width: calc(100% - 20px); /* Adjust width to align roughly */
            max-width: 600px; /* Max width for grid */
            margin: 0 auto; /* Center grid */
        }

        .step-button {
            width: 100%; /* Fill grid cell */
            aspect-ratio: 1 / 1; /* Make buttons square */
            background-color: var(--grey-dark);
            border: 1px solid var(--grey-medium);
            border-radius: 3px;
            cursor: pointer;
        }
        .step-button:hover {
            background-color: var(--grey-medium);
            border-color: var(--grey-light);
        }
        .step-button.active {
            background-color: var(--accent-color);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.4);
        }
        .step-button.playing.active {
            /* Highlight active playing step */
             background-color: white;
             border-color: white;
        }
         .step-button.playing:not(.active) {
            /* Slightly different background for non-active playing step? Optional */
            /* background-color: #555; */
         }

    </style>
</head>
<body>

<div class="drum-machine-panel" id="drum-machine-panel">
    <div class="header-area">
        <h1>AH DS-02</h1>
    </div>

    <!-- Voice Modules (HTML unchanged from previous version) -->
    <!-- Voice 1 (A) -->
    <div class="module voice-module" id="voice-module-0">
        <div class="indicator-light" id="light-0"></div>
        <div class="control-grid">
            <div class="control-group"><label for="v0-pitch">Pitch</label><div class="knob" id="v0-pitch" data-param="voices.0.pitch" data-min="20" data-max="2000" data-value="80" data-curve="log" tabindex="0"></div><span class="knob-value-display" id="v0-pitch-value"></span></div>
            <div class="control-group"><label for="v0-wave"><span class="waveform-label" id="v0-wave-indicator">∿</span></label><div class="knob" id="v0-wave" data-param="voices.0.wave" data-steps="sine,square,sawtooth,noise" data-value="0" tabindex="0"></div></div>
            <div class="control-group"><label for="v0-level">Level</label><div class="knob" id="v0-level" data-param="voices.0.level" data-min="0" data-max="1" data-value="0.8" tabindex="0"></div><span class="knob-value-display" id="v0-level-value"></span></div>
            <div class="control-group"><label for="v0-cutoff">Cutoff</label><div class="knob" id="v0-cutoff" data-param="voices.0.cutoff" data-min="40" data-max="20000" data-value="40" data-curve="log" tabindex="0"></div><span class="knob-value-display" id="v0-cutoff-value"></span></div>
            <div class="adsr-grid">
                <div class="control-group"><label for="v0-attack">A</label><div class="knob" id="v0-attack" data-param="voices.0.env.attack" data-min="0.001" data-max="0.05" data-value="0.001" tabindex="0"></div><span class="knob-value-display" id="v0-attack-value"></span></div>
                <div class="control-group"><label for="v0-decay">D</label><div class="knob" id="v0-decay" data-param="voices.0.env.decay" data-min="0.001" data-max="0.3" data-value="0.03" tabindex="0"></div><span class="knob-value-display" id="v0-decay-value"></span></div>
                <div class="control-group"><label for="v0-sustain">S</label><div class="knob" id="v0-sustain" data-param="voices.0.env.sustain" data-min="0" data-max="1" data-value="0" tabindex="0"></div><span class="knob-value-display" id="v0-sustain-value"></span></div>
                <div class="control-group"><label for="v0-release">R</label><div class="knob" id="v0-release" data-param="voices.0.env.release" data-min="0.001" data-max="2" data-value="0.1" tabindex="0"></div><span class="knob-value-display" id="v0-release-value"></span></div>
            </div>
        </div>
    </div>
    <!-- Voice 2 (S) -->
    <div class="module voice-module" id="voice-module-1">
        <div class="indicator-light" id="light-1"></div>
        <div class="control-grid">
            <div class="control-group"><label for="v1-pitch">Pitch</label><div class="knob" id="v1-pitch" data-param="voices.1.pitch" data-min="20" data-max="2000" data-value="180" data-curve="log" tabindex="0"></div><span class="knob-value-display" id="v1-pitch-value"></span></div>
            <div class="control-group"><label for="v1-wave"><span class="waveform-label" id="v1-wave-indicator">∿</span></label><div class="knob" id="v1-wave" data-param="voices.1.wave" data-steps="sine,square,sawtooth,noise" data-value="3" tabindex="0"></div></div>
            <div class="control-group"><label for="v1-level">Level</label><div class="knob" id="v1-level" data-param="voices.1.level" data-min="0" data-max="1" data-value="0.5" tabindex="0"></div><span class="knob-value-display" id="v1-level-value"></span></div>
            <div class="control-group"><label for="v1-cutoff">Cutoff</label><div class="knob" id="v1-cutoff" data-param="voices.1.cutoff" data-min="40" data-max="20000" data-value="100" data-curve="log" tabindex="0"></div><span class="knob-value-display" id="v1-cutoff-value"></span></div>
            <div class="adsr-grid">
                <div class="control-group"><label for="v1-attack">A</label><div class="knob" id="v1-attack" data-param="voices.1.env.attack" data-min="0.001" data-max="0.05" data-value="0.001" tabindex="0"></div><span class="knob-value-display" id="v1-attack-value"></span></div>
                <div class="control-group"><label for="v1-decay">D</label><div class="knob" id="v1-decay" data-param="voices.1.env.decay" data-min="0.001" data-max="0.3" data-value="0.05" tabindex="0"></div><span class="knob-value-display" id="v1-decay-value"></span></div>
                <div class="control-group"><label for="v1-sustain">S</label><div class="knob" id="v1-sustain" data-param="voices.1.env.sustain" data-min="0" data-max="1" data-value="0.2" tabindex="0"></div><span class="knob-value-display" id="v1-sustain-value"></span></div>
                <div class="control-group"><label for="v1-release">R</label><div class="knob" id="v1-release" data-param="voices.1.env.release" data-min="0.001" data-max="2" data-value="0.2" tabindex="0"></div><span class="knob-value-display" id="v1-release-value"></span></div>
            </div>
        </div>
    </div>
    <!-- Voice 3 (D) -->
    <div class="module voice-module" id="voice-module-2">
        <div class="indicator-light" id="light-2"></div>
        <div class="control-grid">
            <div class="control-group"><label for="v2-pitch">Pitch</label><div class="knob" id="v2-pitch" data-param="voices.2.pitch" data-min="20" data-max="4000" data-value="800" data-curve="log" tabindex="0"></div><span class="knob-value-display" id="v2-pitch-value"></span></div>
            <div class="control-group"><label for="v2-wave"><span class="waveform-label" id="v2-wave-indicator">∿</span></label><div class="knob" id="v2-wave" data-param="voices.2.wave" data-steps="sine,square,sawtooth,noise" data-value="3" tabindex="0"></div></div>
            <div class="control-group"><label for="v2-level">Level</label><div class="knob" id="v2-level" data-param="voices.2.level" data-min="0" data-max="1" data-value="0.5" tabindex="0"></div><span class="knob-value-display" id="v2-level-value"></span></div>
            <div class="control-group"><label for="v2-cutoff">Cutoff</label><div class="knob" id="v2-cutoff" data-param="voices.2.cutoff" data-min="40" data-max="20000" data-value="5000" data-curve="log" tabindex="0"></div><span class="knob-value-display" id="v2-cutoff-value"></span></div>
            <div class="adsr-grid">
                <div class="control-group"><label for="v2-attack">A</label><div class="knob" id="v2-attack" data-param="voices.2.env.attack" data-min="0.001" data-max="0.5" data-value="0.001" tabindex="0"></div><span class="knob-value-display" id="v2-attack-value"></span></div>
                <div class="control-group"><label for="v2-decay">D</label><div class="knob" id="v2-decay" data-param="voices.2.env.decay" data-min="0.001" data-max="0.3" data-value="0.03" tabindex="0"></div><span class="knob-value-display" id="v2-decay-value"></span></div>
                <div class="control-group"><label for="v2-sustain">S</label><div class="knob" id="v2-sustain" data-param="voices.2.env.sustain" data-min="0" data-max="1" data-value="0" tabindex="0"></div><span class="knob-value-display" id="v2-sustain-value"></span></div>
                <div class="control-group"><label for="v2-release">R</label><div class="knob" id="v2-release" data-param="voices.2.env.release" data-min="0.001" data-max="1" data-value="0.1" tabindex="0"></div><span class="knob-value-display" id="v2-release-value"></span></div>
            </div>
        </div>
    </div>
    <!-- Voice 4 (F) -->
    <div class="module voice-module" id="voice-module-3">
        <div class="indicator-light" id="light-3"></div>
        <div class="control-grid">
            <div class="control-group"><label for="v3-pitch">Pitch</label><div class="knob" id="v3-pitch" data-param="voices.3.pitch" data-min="100" data-max="8000" data-value="3500" data-curve="log" tabindex="0"></div><span class="knob-value-display" id="v3-pitch-value"></span></div>
            <div class="control-group"><label for="v3-wave"><span class="waveform-label" id="v3-wave-indicator">∿</span></label><div class="knob" id="v3-wave" data-param="voices.3.wave" data-steps="sine,square,sawtooth,noise" data-value="3" tabindex="0"></div></div>
            <div class="control-group"><label for="v3-level">Level</label><div class="knob" id="v3-level" data-param="voices.3.level" data-min="0" data-max="1" data-value="0.5" tabindex="0"></div><span class="knob-value-display" id="v3-level-value"></span></div>
            <div class="control-group"><label for="v3-cutoff">Cutoff</label><div class="knob" id="v3-cutoff" data-param="voices.3.cutoff" data-min="40" data-max="20000" data-value="5000" data-curve="log" tabindex="0"></div><span class="knob-value-display" id="v3-cutoff-value"></span></div>
            <div class="adsr-grid">
                <div class="control-group"><label for="v3-attack">A</label><div class="knob" id="v3-attack" data-param="voices.3.env.attack" data-min="0.001" data-max="0.2" data-value="0.001" tabindex="0"></div><span class="knob-value-display" id="v3-attack-value"></span></div>
                <div class="control-group"><label for="v3-decay">D</label><div class="knob" id="v3-decay" data-param="voices.3.env.decay" data-min="0.001" data-max="0.5" data-value="0.3" tabindex="0"></div><span class="knob-value-display" id="v3-decay-value"></span></div>
                <div class="control-group"><label for="v3-sustain">S</label><div class="knob" id="v3-sustain" data-param="voices.3.env.sustain" data-min="0" data-max="1" data-value="0" tabindex="0"></div><span class="knob-value-display" id="v3-sustain-value"></span></div>
                <div class="control-group"><label for="v3-release">R</label><div class="knob" id="v3-release" data-param="voices.3.env.release" data-min="0.001" data-max="0.5" data-value="0.03" tabindex="0"></div><span class="knob-value-display" id="v3-release-value"></span></div>
            </div>
        </div>
    </div>
    <!-- Effects & Master (HTML unchanged) -->
    <div class="module" id="effects-master-module">
        <div class="effects-control-row">
            <div class="control-group">
                <label for="delay-time">Dly Time</label>
                <div class="knob" id="delay-time" data-param="effects.delay.time" data-min="0.01" data-max="1" data-value="0.15" data-curve="log" tabindex="0"></div>
                <span class="knob-value-display" id="delay-time-value"></span>
            </div>
            <div class="control-group">
                <label for="delay-feedback">Dly Fdbk</label>
                <div class="knob" id="delay-feedback" data-param="effects.delay.feedback" data-min="0" data-max="0.95" data-value=".4" tabindex="0"></div>
                <span class="knob-value-display" id="delay-feedback-value"></span>
            </div>
        </div>
        <div class="effects-control-row">
            <div class="control-group">
                <label for="delay-level">Dly Level</label>
                <div class="knob" id="delay-level" data-param="effects.delay.level" data-min="0" data-max="1" data-value="0" tabindex="0"></div><span class="knob-value-display" id="delay-level-value"></span>
            </div>
            <div class="control-group">
                <label for="reverb-level">Reverb</label>
                <div class="knob" id="reverb-level" data-param="effects.reverb.level" data-min="0" data-max="1" data-value="0" tabindex="0"></div>
                <span class="knob-value-display" id="reverb-level-value"></span>
            </div>
        </div>
        <div style="margin-top: auto;" class="effects-control-row">
            <div class="control-group">
                <label for="distortion-amount">Drive</label>
                <div class="knob" id="distortion-amount" data-param="effects.distortion.amount" data-min="0" data-max="100" data-value="0" tabindex="0"></div>
                <span class="knob-value-display" id="distortion-amount-value"></span>
            </div>
            <div class="control-group">
                <label for="volume">Volume</label>
                <div class="knob" id="volume" data-param="masterVolume" data-min="0" data-max="1" data-value="0.6" tabindex="0"></div><span class="knob-value-display" id="volume-value"></span></div></div>
    </div>

    <!-- Sequencer Panel -->
    <div class="sequencer-panel" id="sequencer-panel">
        <div class="sequencer-controls">
            <button id="play-stop-button" class="seq-button">▶︎</button>
            <div class="tempo-control">
                <input type="number" id="tempo-input" class="tempo-input" value="120" min="30" max="300">
            </div>
            <button id="reset-button" class="seq-button">⨂</button>
        </div>
        <div class="sequencer-grid-container">
            <div class="step-indicator-row" id="step-indicator-row">
                <!-- Indicators will be generated by JS -->
            </div>
            <div class="sequencer-grid" id="sequencer-grid">
                <!-- Step buttons will be generated by JS -->
            </div>
        </div>
    </div>
</div> <!-- End of drum-machine-panel -->



<script>
    // ----- UI ELEMENTS -----
    const drumMachinePanel = document.getElementById('drum-machine-panel');
    let knobs; // Populated later
    const indicatorLights = Array.from({ length: 4 }, (_, i) => document.getElementById(`light-${i}`));
    const waveformIndicators = Array.from({ length: 4 }, (_, i) => document.getElementById(`v${i}-wave-indicator`));
    // Sequencer UI Elements
    const sequencerPanel = document.getElementById('sequencer-panel');
    const playStopButton = document.getElementById('play-stop-button');
    const tempoInput = document.getElementById('tempo-input');
    const resetButton = document.getElementById('reset-button');
    const stepIndicatorRow = document.getElementById('step-indicator-row');
    const sequencerGrid = document.getElementById('sequencer-grid');
    let stepButtons = []; // 2D array [voice][step]
    let stepIndicators = []; // Array of indicator divs

    // ----- AUDIO CONTEXT & NODES -----
    let audioContext;
    let masterGain;
    let effectsInput;
    let distortionPreGain;
    let distortion;
    let delay, delayFeedbackGain, delayWetGain;
    let reverb, reverbWetGain;
    let noiseBuffer;

    let isAudioInitialized = false;
    let isAudioResumed = false;

    // ----- SYNTH PARAMETERS -----
    const NUM_VOICES = 4;
    const NUM_STEPS = 16;
    const WAVEFORMS = ['sine', 'square', 'sawtooth', 'noise'];
    const WAVEFORM_INDICATORS = ['∿', '⨅', '⩘', '░'];

    const params = {
        voices: Array.from({ length: NUM_VOICES }, (_, i) => ({ // Default values, adjusted for example
            pitch: [60, 180, 800, 3500][i],
            wave: [0, 3, 3, 3][i],
            level: [0.8, 0.7, 0.7, 0.6][i],
            cutoff: [40, 100, 200, 5000][i], // High-pass defaults
            env: {
                attack: [0.01, 0.005, 0.002, 0.001][i],
                decay: [0.15, 0.12, 0.08, 0.05][i],
                sustain: 0,
                release: [0.1, 0.05, 0.1, 0.03][i]
            }
        })),
        effects: {
            distortion: { amount: 0 },
            delay: { time: 0.15, feedback: 0.4, level: 0 },
            reverb: { level: 0 }
        },
        masterVolume: 0.6
    };

    let activeSources = Array.from({ length: NUM_VOICES }, () => []);

    // ----- KEY MAPPING -----
    const keyToVoiceIndex = { 'KeyA': 0, 'KeyS': 1, 'KeyD': 2, 'KeyF': 3 };

    // ----- SEQUENCER STATE -----
    const sequencer = {
        steps: Array.from({ length: NUM_VOICES }, () => Array(NUM_STEPS).fill(0)),
        tempo: 120.0,
        currentStep: 0,
        isPlaying: false,
        startTime: 0,           // AudioContext time when sequencer started
        nextStepTime: 0,        // AudioContext time of the next step
        stepDuration: 0,        // Duration of a 16th note in seconds
        lookahead: 25.0,        // How often to schedule notes (ms)
        scheduleAheadTime: 0.1, // How far ahead to schedule notes (s)
        timerId: null           // ID from setTimeout
    };

    // ----- UTILITY FUNCTIONS -----
    // (createNoiseBuffer, makeDistortionCurve, createReverbImpulse, formatKnobValue, updateKnobValueDisplay - unchanged)
    function createNoiseBuffer(context){const bufferSize=context.sampleRate*2;const buffer=context.createBuffer(1,bufferSize,context.sampleRate);const output=buffer.getChannelData(0);for(let i=0;i<bufferSize;i++){output[i]=Math.random()*2-1;}return buffer;}
    function makeDistortionCurve(amount,context){if(!context)return null;const k=Math.max(0,amount);const n_samples=44100;const curve=new Float32Array(n_samples);const curveSharpness=1+(k/100)*10;for(let i=0;i<n_samples;++i){let x=i*2/n_samples-1;curve[i]=Math.tanh(x*curveSharpness);}return curve;}
    function createReverbImpulse(context,duration=0.8,decay=1){const sampleRate=context.sampleRate;const length=sampleRate*duration;const impulse=context.createBuffer(2,length,sampleRate);const impulseL=impulse.getChannelData(0);const impulseR=impulse.getChannelData(1);for(let i=0;i<length;i++){const n=length-i;impulseL[i]=(Math.random()*2-1)*Math.pow(n/length,decay);impulseR[i]=(Math.random()*2-1)*Math.pow(n/length,decay);}return impulse;}
    function formatKnobValue(value,knobId){if(typeof value!=='number'||!isFinite(value))return'---';if(knobId){if(knobId.includes('attack')||knobId.includes('decay')||knobId.includes('release')||knobId.includes('delay-time')){return value<1?(value*1000).toFixed(0)+'ms':value.toFixed(2)+'s';}else if(knobId.includes('pitch')||knobId.includes('cutoff')){return value>=1000?(value/1000).toFixed(1)+'k':value.toFixed(0);}else if(knobId.includes('level')||knobId.includes('feedback')||knobId.includes('sustain')||knobId.includes('volume')){return value.toFixed(2);}else if(knobId.includes('distortion-amount')){return value.toFixed(0);}}return value.toFixed(2);}
    function updateKnobValueDisplay(knob,value){if(knob&&!knob.dataset.steps){const displayId=knob.id+'-value';const displayElement=document.getElementById(displayId);if(displayElement){displayElement.textContent=formatKnobValue(value,knob.id);}}}


    // ----- AUDIO CONTEXT & INITIALIZATION -----
    async function ensureAudioContextResumed() { // (unchanged)
        if (!audioContext) return false;
        if (audioContext.state === 'running') { if (!isAudioResumed) { isAudioResumed = true; masterGain.gain.linearRampToValueAtTime(params.masterVolume, audioContext.currentTime + 0.05); } return true; }
        if (audioContext.state === 'suspended') { try { await audioContext.resume(); if (audioContext.state === 'running') { console.log("AudioContext Resumed."); isAudioResumed = true; masterGain.gain.linearRampToValueAtTime(params.masterVolume, audioContext.currentTime + 0.05); return true; } else { isAudioResumed = false; return false; } } catch (e) { console.error("Error resuming:", e); isAudioResumed = false; return false; } } return false;
    }

    async function initAudio() { // (unchanged from previous version with distortion fix)
        if (isAudioInitialized) return;
        console.log("Initializing AudioContext...");
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)(); if (!audioContext) throw new Error("Web Audio API not supported."); isAudioInitialized = true; console.log("Initial State:", audioContext.state);
            masterGain = audioContext.createGain(); masterGain.gain.value = 0; effectsInput = audioContext.createGain();
            distortionPreGain = audioContext.createGain(); distortion = audioContext.createWaveShaper(); delay = audioContext.createDelay(2.0); delayFeedbackGain = audioContext.createGain(); delayWetGain = audioContext.createGain(); reverb = audioContext.createConvolver(); reverbWetGain = audioContext.createGain();
            noiseBuffer = createNoiseBuffer(audioContext); reverb.buffer = createReverbImpulse(audioContext);
            effectsInput.connect(distortionPreGain); distortionPreGain.connect(distortion); distortion.connect(masterGain);
            distortion.connect(delay); delay.connect(delayFeedbackGain); delayFeedbackGain.connect(delay); delay.connect(delayWetGain); delayWetGain.connect(masterGain);
            distortion.connect(reverb); reverb.connect(reverbWetGain); reverbWetGain.connect(masterGain);
            masterGain.connect(audioContext.destination);
            updateParameterValue('effects.distortion.amount', params.effects.distortion.amount, true); updateParameterValue('effects.delay.time', params.effects.delay.time, true); updateParameterValue('effects.delay.feedback', params.effects.delay.feedback, true); updateParameterValue('effects.delay.level', params.effects.delay.level, true); updateParameterValue('effects.reverb.level', params.effects.reverb.level, true); updateParameterValue('masterVolume', params.masterVolume, true);
            if (audioContext.state === 'running') { isAudioResumed = true; masterGain.gain.value = params.masterVolume; } else { isAudioResumed = false; console.log("Context suspended."); }
        } catch (e) { console.error("Audio Init Error:", e); isAudioInitialized = false; isAudioResumed = false; alert("Audio Init Error: " + e.message); }
    }

    // ----- DRUM VOICE TRIGGERING -----
    function triggerDrumSound(voiceIndex, playTime = audioContext.currentTime) { // Added playTime parameter
        if (!isAudioInitialized || !audioContext) return; // No need to check isAudioResumed here, scheduling handles it

        const voiceParams = params.voices[voiceIndex];
        const waveType = WAVEFORMS[voiceParams.wave];
        const now = playTime; // Use scheduled time
        const env = voiceParams.env;
        const voiceLevel = voiceParams.level;
        const voiceCutoff = voiceParams.cutoff;

        // Stop Previous Sounds - Not strictly needed if scheduling correctly, but good practice for manual triggers
        // activeSources[voiceIndex].forEach(nodes => { /* ... */ }); // Keep if manual triggers are still desired
        // activeSources[voiceIndex] = [];

        // Create Nodes
        let sourceNode;
        const sourceGain = audioContext.createGain();
        const levelGain = audioContext.createGain();
        const filterNode = audioContext.createBiquadFilter();
        const envelopeGain = audioContext.createGain();

        filterNode.type = 'highpass'; // Corrected to highpass
        filterNode.frequency.setValueAtTime(voiceCutoff, now); // Set value at scheduled time
        filterNode.Q.setValueAtTime(1, now);
        levelGain.gain.setValueAtTime(voiceLevel, now);

        // Create Source
        if (waveType === 'noise') {
            sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = noiseBuffer;
            sourceNode.loop = false;
        } else {
            sourceNode = audioContext.createOscillator();
            sourceNode.type = waveType;
            sourceNode.frequency.setValueAtTime(voiceParams.pitch, now);
        }

        // Connect Path
        sourceNode.connect(sourceGain);
        sourceGain.connect(levelGain);
        levelGain.connect(filterNode);
        filterNode.connect(envelopeGain);
        envelopeGain.connect(effectsInput);
        sourceGain.gain.value = 1;

        // Apply ADSR Envelope
        const peakLevel = 1.0;
        const sustainLevel = Math.max(0.0001, env.sustain * peakLevel);
        const attackTime = Math.max(0.001, env.attack);
        const decayTime = Math.max(0.001, env.decay);
        const releaseTime = Math.max(0.001, env.release);
        const totalDuration = attackTime + decayTime + releaseTime;

        envelopeGain.gain.cancelScheduledValues(now);
        envelopeGain.gain.setValueAtTime(0, now);
        envelopeGain.gain.linearRampToValueAtTime(peakLevel, now + attackTime);
        envelopeGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        envelopeGain.gain.setValueAtTime(sustainLevel, now + attackTime + decayTime); // Hold before release
        envelopeGain.gain.linearRampToValueAtTime(0.00001, now + totalDuration);

        // Start and Stop Source
        sourceNode.start(now);
        sourceNode.stop(now + totalDuration + 0.05); // Stop slightly after envelope finishes

        // --- Visual Feedback (Manual Trigger Only) ---
        // Don't flash light for sequencer triggers, indicator row handles it
        // const light = indicatorLights[voiceIndex];
        // light.classList.add('active');
        // setTimeout(() => light.classList.remove('active'), 100);
    }

    // ----- UI UPDATE FUNCTIONS -----
    // (updateKnobVisual - unchanged)
    function updateKnobVisual(knob, valueForRotation, actualAudioValue) { knob.dataset.actualValue = typeof actualAudioValue === 'number' ? actualAudioValue.toFixed(5) : String(actualAudioValue); const steps = knob.dataset.steps ? knob.dataset.steps.split(',') : null; let percentage = Math.max(0, Math.min(1, valueForRotation)); if (steps) { const numSteps = steps.length; const stepIndex = numSteps > 1 ? Math.round(percentage * (numSteps - 1)) : 0; if (knob.id.includes('-wave')) { const voiceIndex = parseInt(knob.id.match(/v(\d+)-/)[1]); if (waveformIndicators[voiceIndex]) { waveformIndicators[voiceIndex].textContent = WAVEFORM_INDICATORS[stepIndex] || '?'; } } } else { updateKnobValueDisplay(knob, actualAudioValue); } const rotation = -135 + (percentage * 270); knob.style.transform = `rotate(${rotation}deg)`; }

    function updateParameterValue(paramPath, value, forceUpdate = false) { // (unchanged)
        const parts = paramPath.split('.'); let currentParamObj = params;
        try { for (let i = 0; i < parts.length - 1; i++) { if (!currentParamObj[parts[i]]) currentParamObj[parts[i]] = {}; currentParamObj = currentParamObj[parts[i]]; } const finalKey = parts[parts.length - 1]; if (typeof value === 'string' && !isNaN(parseFloat(value))) { value = parseFloat(value); } currentParamObj[finalKey] = value; } catch (e) { console.error("Error updating internal params:", paramPath, value, e); return; }
        if (isAudioInitialized && (isAudioResumed || forceUpdate) && audioContext) { const now = audioContext.currentTime; const rampTime = 0.01; try { if (paramPath === 'masterVolume' && masterGain) { masterGain.gain.setTargetAtTime(value, now, rampTime); } else if (paramPath === 'effects.distortion.amount' && distortion && distortionPreGain) { const preGainValue = 1 + (value / 100) * 9; distortionPreGain.gain.setTargetAtTime(preGainValue, now, rampTime); distortion.curve = makeDistortionCurve(value, audioContext); distortion.oversample = value > 15 ? '4x' : (value > 5 ? '2x' : 'none'); } else if (paramPath === 'effects.delay.time' && delay) { delay.delayTime.setTargetAtTime(value, now, rampTime); } else if (paramPath === 'effects.delay.feedback' && delayFeedbackGain) { delayFeedbackGain.gain.setTargetAtTime(value, now, rampTime); } else if (paramPath === 'effects.delay.level' && delayWetGain) { delayWetGain.gain.setTargetAtTime(value, now, rampTime); } else if (paramPath === 'effects.reverb.level' && reverbWetGain) { reverbWetGain.gain.setTargetAtTime(value, now, rampTime); } } catch (e) { console.error(`Error setting AudioNode param ${paramPath}:`, e, "Value:", value); } }
    }
    function updateParameterFromKnob(knob, newValue, forceUpdate = false) { // (unchanged)
        const paramPath = knob.dataset.param; const min = parseFloat(knob.dataset.min); const max = parseFloat(knob.dataset.max); const steps = knob.dataset.steps ? knob.dataset.steps.split(',') : null; const isLog = knob.dataset.curve === 'log'; let uiValue = newValue; let actualAudioValue; let percentageForVisual = 0.5;
        if (steps) { const stepIndex = Math.max(0, Math.min(steps.length - 1, Math.round(parseFloat(newValue)))); uiValue = stepIndex; actualAudioValue = stepIndex; knob.dataset.value = uiValue; percentageForVisual = steps.length > 1 ? stepIndex / (steps.length - 1) : 0.5; } else { const numericValue = parseFloat(newValue); uiValue = Math.max(min, Math.min(max, numericValue)); actualAudioValue = uiValue; knob.dataset.value = uiValue.toFixed(5); if (isLog && min > 0) { if (uiValue <= min) percentageForVisual = 0; else if (uiValue >= max) percentageForVisual = 1; else percentageForVisual = Math.log(uiValue / min) / Math.log(max / min); } else { const range = max - min; percentageForVisual = range > 0 ? (actualAudioValue - min) / range : 0.5; } }
        percentageForVisual = Math.max(0, Math.min(1, isNaN(percentageForVisual) ? 0.5 : percentageForVisual)); updateKnobVisual(knob, percentageForVisual, actualAudioValue); updateParameterValue(paramPath, actualAudioValue, forceUpdate);
    }

    function updateAllKnobs(forceUpdate = false) { // (unchanged)
        if (!knobs) knobs = drumMachinePanel.querySelectorAll('.knob'); knobs.forEach(knob => { const initialValueAttr = knob.getAttribute('data-value'); const currentDatasetValue = knob.dataset.value; let valueToUse = (forceUpdate || currentDatasetValue === undefined || currentDatasetValue === null) ? initialValueAttr : currentDatasetValue; if (valueToUse !== null) { updateParameterFromKnob(knob, valueToUse, forceUpdate); } else { console.warn("Knob missing value:", knob.id); } if (!knob.dataset.steps) { const displayId = knob.id + '-value'; const displayElement = document.getElementById(displayId); if (displayElement && document.activeElement !== knob) { displayElement.style.display = 'none'; } } });
    }


    // ----- SEQUENCER LOGIC -----

    // Function to schedule notes for upcoming steps
    function scheduleNotes(currentStep, currentTime) {
        sequencer.stepDuration = 60.0 / sequencer.tempo / 4.0; // Duration of one 16th note

        while (sequencer.nextStepTime < currentTime + sequencer.scheduleAheadTime) {
            const stepIndex = sequencer.currentStep;
            const stepTime = sequencer.nextStepTime;

            for (let voiceIndex = 0; voiceIndex < NUM_VOICES; voiceIndex++) {
                if (sequencer.steps[voiceIndex][stepIndex] === 1) {
                    triggerDrumSound(voiceIndex, stepTime);
                }
            }
            // Update visual indicator just before the step is meant to play
             updateStepIndicator(stepIndex, stepTime);

            // Advance to the next step time
            sequencer.nextStepTime += sequencer.stepDuration;
            sequencer.currentStep = (sequencer.currentStep + 1) % NUM_STEPS;
        }
    }

    // The main timer loop
    function sequencerScheduler() {
        if (!sequencer.isPlaying) return;

        const currentTime = audioContext.currentTime;
        scheduleNotes(sequencer.currentStep, currentTime);

        // Schedule the next check
        sequencer.timerId = setTimeout(sequencerScheduler, sequencer.lookahead);
    }

    function playSequencer() {
        if (!isAudioInitialized || !isAudioResumed) {
            console.warn("Audio not ready, cannot start sequencer.");
            // Optionally try to resume audio here
             ensureAudioContextResumed().then(resumed => {
                 if (resumed) playSequencer(); // Try again if resumed successfully
             });
            return;
        }
        if (sequencer.isPlaying) return;

        sequencer.isPlaying = true;
        sequencer.currentStep = 0; // Start from step 0
        sequencer.nextStepTime = audioContext.currentTime + 0.05; // Start scheduling slightly ahead
        sequencerScheduler(); // Start the scheduling loop

        playStopButton.textContent = "⏹";
        playStopButton.classList.add("playing");
    }

    function stopSequencer() {
        if (!sequencer.isPlaying) return;

        sequencer.isPlaying = false;
        clearTimeout(sequencer.timerId); // Stop the scheduling loop
        sequencer.timerId = null;

        playStopButton.textContent = "▶︎";
        playStopButton.classList.remove("playing");
        clearStepIndicators(); // Reset indicators
    }

    function togglePlayStop() {
        if (sequencer.isPlaying) {
            stopSequencer();
        } else {
            playSequencer();
        }
    }

    function updateTempo(newTempo) {
        const clampedTempo = Math.max(30, Math.min(300, newTempo)); // Clamp BPM
        sequencer.tempo = clampedTempo;
        tempoInput.value = clampedTempo; // Update input field in case it was clamped
        // The stepDuration will be recalculated in the next scheduleNotes call
    }

    function resetSequencer() {
        stopSequencer();
        for (let v = 0; v < NUM_VOICES; v++) {
            for (let s = 0; s < NUM_STEPS; s++) {
                sequencer.steps[v][s] = 0;
                stepButtons[v][s].classList.remove('active');
            }
        }
        sequencer.currentStep = 0;
        clearStepIndicators();
        console.log("Sequencer Reset.");
    }

     function toggleStep(voiceIndex, stepIndex) {
        sequencer.steps[voiceIndex][stepIndex] = 1 - sequencer.steps[voiceIndex][stepIndex]; // Toggle 0/1
        stepButtons[voiceIndex][stepIndex].classList.toggle('active');
     }

     // --- Sequencer Visuals ---
     function createSequencerGridUI() {
         // Create Step Indicators
         stepIndicatorRow.innerHTML = ''; // Clear previous
         stepIndicators = [];
         for (let i = 0; i < NUM_STEPS; i++) {
             const indicator = document.createElement('div');
             indicator.classList.add('step-indicator');
             indicator.id = `step-indicator-${i}`;
             stepIndicatorRow.appendChild(indicator);
             stepIndicators.push(indicator);
         }

         // Create Step Buttons
         sequencerGrid.innerHTML = ''; // Clear previous
         stepButtons = [];
         for (let v = 0; v < NUM_VOICES; v++) {
             stepButtons[v] = [];
             for (let s = 0; s < NUM_STEPS; s++) {
                 const button = document.createElement('button');
                 button.classList.add('step-button');
                 button.dataset.voice = v;
                 button.dataset.step = s;
                 button.addEventListener('click', () => toggleStep(v, s));
                 sequencerGrid.appendChild(button);
                 stepButtons[v].push(button);
             }
         }
     }

     let lastIndicatorUpdate = { step: -1, timeoutId: null };

     function updateStepIndicator(stepIndex) {
         // Clear previous indicator timeout if it exists
         if (lastIndicatorUpdate.timeoutId) {
             clearTimeout(lastIndicatorUpdate.timeoutId);
             if(lastIndicatorUpdate.step >= 0 && lastIndicatorUpdate.step < NUM_STEPS) {
                  stepIndicators[lastIndicatorUpdate.step]?.classList.remove('active');
                  // Also remove playing class from step buttons of previous step
                   for(let v = 0; v < NUM_VOICES; v++){
                        stepButtons[v][lastIndicatorUpdate.step]?.classList.remove('playing');
                   }
             }
         }

         // Light up the current step indicator
         if(stepIndex >= 0 && stepIndex < NUM_STEPS) {
             stepIndicators[stepIndex]?.classList.add('active');
             // Add playing class to step buttons of current step
             for(let v = 0; v < NUM_VOICES; v++){
                 stepButtons[v][stepIndex]?.classList.add('playing');
            }
         }

         // Schedule the indicator and button highlight to turn off shortly after step duration
         const indicatorOffDelay = (sequencer.stepDuration * 1000) * 0.8; // Turn off slightly before next step
         lastIndicatorUpdate.step = stepIndex;
         lastIndicatorUpdate.timeoutId = setTimeout(() => {
            if(stepIndex >= 0 && stepIndex < NUM_STEPS) {
                 stepIndicators[stepIndex]?.classList.remove('active');
                 for(let v = 0; v < NUM_VOICES; v++){
                     stepButtons[v][stepIndex]?.classList.remove('playing');
                 }
            }
             lastIndicatorUpdate.timeoutId = null; // Clear the stored ID
         }, indicatorOffDelay);
     }


     function clearStepIndicators() {
         if (lastIndicatorUpdate.timeoutId) {
             clearTimeout(lastIndicatorUpdate.timeoutId);
             lastIndicatorUpdate.timeoutId = null;
         }
         stepIndicators.forEach(ind => ind.classList.remove('active'));
         stepButtons.flat().forEach(btn => btn.classList.remove('playing'));
         lastIndicatorUpdate.step = -1;
     }


    // ----- EVENT LISTENERS -----

        // -- Keyboard Input for Triggering Drums & Sequencer --
        document.addEventListener('keydown', async (e) => {
        // Ignore repeats or if modifier keys are pressed
        if (e.repeat || e.metaKey || e.ctrlKey || e.altKey) return;

        // Sequencer Play/Stop Toggle with Spacebar (handles its own preventDefault)
        if (e.code === 'Space') {
            e.preventDefault(); // Prevent page scrolling
            togglePlayStop();
            return; // Don't process other keys if space was pressed
        }

        // --- Manual Drum Triggers ---
        const voiceIndex = keyToVoiceIndex[e.code];
        if (voiceIndex !== undefined) {
             // Prevent default behavior only if it's a drum trigger key
             e.preventDefault();
             let canPlay = isAudioResumed;
             if (!canPlay && isAudioInitialized) canPlay = await ensureAudioContextResumed();

             // Trigger sound immediately for manual play, respecting audio readiness
             if (canPlay) {
                triggerDrumSound(voiceIndex, audioContext.currentTime); // Play sound now

                // --- ADD VISUAL FEEDBACK FOR MANUAL TRIGGER ---
                const light = indicatorLights[voiceIndex];
                if (light) { // Check if light element exists
                    light.classList.add('active');
                    setTimeout(() => light.classList.remove('active'), 100); // Flash light briefly
                }
                // --- END OF VISUAL FEEDBACK ---

             } else {
                console.warn("Audio context not running for manual trigger.");
             }
             // We handled the drum key, don't process knob controls for this event
             return;
        }

        // --- Knob Keyboard Control (Only runs if not a drum trigger key or space) ---
        if (document.activeElement && document.activeElement.classList.contains('knob')) {
            const focusedKnob = document.activeElement;
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                e.preventDefault();
                handleKnobArrowKey(focusedKnob, e.key === 'ArrowLeft' ? -1 : 1, e.shiftKey);
            } else if (e.key >= '0' && e.key <= '9') {
                e.preventDefault();
                handleKnobNumberKey(focusedKnob, parseInt(e.key, 10));
            }
        }
    });

     // --- Knob Keyboard Control Helpers ---
     // (getKnobPercentage, handleKnobArrowKey, handleKnobNumberKey remain the same)
      function getKnobPercentage(knob){const min=parseFloat(knob.dataset.min);const max=parseFloat(knob.dataset.max);const steps=knob.dataset.steps?knob.dataset.steps.split(','):null;const isLog=knob.dataset.curve==='log'&&min>0;let currentValueStr=knob.dataset.value;let percentage=0.5;if(currentValueStr===undefined||currentValueStr===null)return 0.5;if(steps){const numSteps=steps.length;const stepIndex=parseInt(currentValueStr);percentage=numSteps>1?stepIndex/(numSteps-1):0.5;}else{let currentValue=parseFloat(knob.dataset.actualValue||currentValueStr);if(isLog){if(currentValue<=min)percentage=0;else if(currentValue>=max)percentage=1;else percentage=Math.log(currentValue/min)/Math.log(max/min);}else{const range=max-min;percentage=range>0?(currentValue-min)/range:0.5;}}return Math.max(0,Math.min(1,isNaN(percentage)?0.5:percentage));}
      function handleKnobArrowKey(knob,direction,isShift){const steps=knob.dataset.steps?knob.dataset.steps.split(','):null;const min=parseFloat(knob.dataset.min);const max=parseFloat(knob.dataset.max);const isLog=knob.dataset.curve==='log'&&min>0;let currentPercentage=getKnobPercentage(knob);let newValue;if(steps){const numSteps=steps.length;let currentStepIndex=Math.round(currentPercentage*(numSteps-1));let stepChange=direction*(isShift?2:1);newValue=Math.max(0,Math.min(numSteps-1,currentStepIndex+stepChange));}else{let percentageChange=direction*(isShift?0.1:0.01);let newPercentage=Math.max(0,Math.min(1,currentPercentage+percentageChange));if(isLog){newValue=min*Math.pow(max/min,newPercentage);}else{const range=max-min;newValue=min+newPercentage*range;}newValue=Math.max(min,Math.min(max,newValue));}updateParameterFromKnob(knob,newValue);}
      function handleKnobNumberKey(knob,number){const steps=knob.dataset.steps?knob.dataset.steps.split(','):null;const min=parseFloat(knob.dataset.min);const max=parseFloat(knob.dataset.max);const isLog=knob.dataset.curve==='log'&&min>0;let targetValue;if(steps){const numSteps=steps.length;if(numSteps===0)return;let targetIndex=(number===0)?numSteps-1:number-1;targetValue=Math.max(0,Math.min(numSteps-1,targetIndex));}else{let currentActualValue=parseFloat(knob.dataset.actualValue||knob.dataset.value||'0');const epsilon=1e-7;let targetPercentage=(number===0)?(Math.abs(currentActualValue-min)<epsilon?1.0:0.0):number/10.0;if(isLog){targetValue=min*Math.pow(max/min,targetPercentage);}else{const range=max-min;targetValue=min+targetPercentage*range;}targetValue=Math.max(min,Math.min(max,targetValue));}updateParameterFromKnob(knob,targetValue);}

    // -- Mouse Input for Knobs --
    // (isDragging, dragKnob, startY, startValuePercentage, handleKnobMouseMove, stopDrag, setupKnobListeners remain the same)
    let isDragging=false;let dragKnob=null;let startY=0;let startValuePercentage=0;
    function handleKnobMouseMove(e){if(!isDragging||!dragKnob)return;e.preventDefault();const currentY=e.clientY;const deltaY=startY-currentY;const steps=dragKnob.dataset.steps?dragKnob.dataset.steps.split(','):null;const min=parseFloat(dragKnob.dataset.min);const max=parseFloat(dragKnob.dataset.max);const isLog=dragKnob.dataset.curve==='log'&&min>0;let newValue;if(steps){const pixelsPerStep=20;const totalSteps=steps.length;if(totalSteps<=1)return;const totalDragPixelsForRange=pixelsPerStep*(totalSteps-1);const percentageChange=totalDragPixelsForRange>0?(deltaY/totalDragPixelsForRange):0;let newPercentage=Math.max(0,Math.min(1,startValuePercentage+percentageChange));newValue=Math.round(newPercentage*(totalSteps-1));}else{const dragRangePixels=150;const deltaPercentage=deltaY/dragRangePixels;let newPercentage=Math.max(0,Math.min(1,startValuePercentage+deltaPercentage));if(isLog){const epsilon=1e-9;const clampedPercentage=Math.max(epsilon,Math.min(1-epsilon,newPercentage));if(min>0&&max>min)newValue=min*Math.pow(max/min,clampedPercentage);else newValue=(newPercentage>0.5)?max:min;}else{const range=max-min;newValue=min+newPercentage*range;}newValue=Math.max(min,Math.min(max,newValue));}let currentValueInDataStr=dragKnob.dataset.value;const tolerance=1e-6;if(steps){if(newValue!==parseInt(currentValueInDataStr)){updateParameterFromKnob(dragKnob,newValue);}}else{if(Math.abs(newValue-parseFloat(currentValueInDataStr))>tolerance){updateParameterFromKnob(dragKnob,newValue);}}}
    function stopDrag(){if(isDragging&&dragKnob){dragKnob.closest('.control-group')?.classList.remove('interacting');}if(isDragging){isDragging=false;dragKnob=null;document.body.classList.remove('dragging');document.removeEventListener('mousemove',handleKnobMouseMove);document.removeEventListener('mouseup',stopDrag);document.removeEventListener('mouseleave',stopDrag);}}
    function setupKnobListeners(){if(!knobs)knobs=drumMachinePanel.querySelectorAll('.knob');knobs.forEach(knob=>{const controlGroup=knob.closest('.control-group');const isStepped=knob.hasAttribute('data-steps');const valueDisplayId=knob.id+'-value';const valueDisplay=document.getElementById(valueDisplayId);if(!isStepped&&valueDisplay){knob.addEventListener('focus',()=>{const currentVal=parseFloat(knob.dataset.actualValue||knob.dataset.value||'0');updateKnobValueDisplay(knob,currentVal);valueDisplay.style.display='inline-block';});knob.addEventListener('blur',()=>{if(!isDragging||dragKnob!==knob){valueDisplay.style.display='none';}controlGroup?.classList.remove('interacting');});}knob.addEventListener('mousedown',async(e)=>{let canInteract=isAudioResumed;if(!canInteract&&isAudioInitialized)canInteract=await ensureAudioContextResumed();if(!isAudioInitialized||!canInteract)return;e.preventDefault();isDragging=true;dragKnob=knob;startY=e.clientY;startValuePercentage=getKnobPercentage(knob);knob.focus();controlGroup?.classList.add('interacting');if(!isStepped&&valueDisplay){const currentVal=parseFloat(knob.dataset.actualValue||knob.dataset.value||'0');updateKnobValueDisplay(knob,currentVal);valueDisplay.style.display='inline-block';}document.body.classList.add('dragging');document.addEventListener('mousemove',handleKnobMouseMove);document.addEventListener('mouseup',stopDrag);document.addEventListener('mouseleave',stopDrag);});knob.addEventListener('dblclick',async(e)=>{let canInteract=isAudioResumed;if(!canInteract&&isAudioInitialized)canInteract=await ensureAudioContextResumed();if(!isAudioInitialized||!canInteract)return;const defaultValueAttr=knob.getAttribute('data-value');if(defaultValueAttr!==null){updateParameterFromKnob(knob,defaultValueAttr);if(!isStepped&&valueDisplay){const defaultVal=parseFloat(defaultValueAttr);updateKnobValueDisplay(knob,defaultVal);}}});});}


    // --- Sequencer UI Event Listeners ---
    function setupSequencerListeners() {
        playStopButton.addEventListener('click', togglePlayStop);
        resetButton.addEventListener('click', resetSequencer);
        tempoInput.addEventListener('change', (e) => {
            const newTempo = parseFloat(e.target.value);
            if (!isNaN(newTempo)) {
                updateTempo(newTempo);
            } else {
                tempoInput.value = sequencer.tempo; // Reset if invalid input
            }
        });
         tempoInput.addEventListener('input', (e) => { // Update visually while typing/spinning
             const currentVal = parseFloat(e.target.value);
             if (!isNaN(currentVal)) {
                 sequencer.tempo = Math.max(30, Math.min(300, currentVal)); // Update internal tempo immediately for timing calc
             }
         });
    }

    // -- General Interaction Listener for Audio Context --
    // (setupGeneralInteractionListener unchanged)
    function setupGeneralInteractionListener(){drumMachinePanel.addEventListener('pointerdown',async()=>{if(!isAudioResumed&&isAudioInitialized){await ensureAudioContextResumed();}},{capture:true,once:true}); sequencerPanel.addEventListener('pointerdown',async()=>{if(!isAudioResumed&&isAudioInitialized){await ensureAudioContextResumed();}},{capture:true,once:true});} // Added sequencer panel too

    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', async () => {
        knobs = drumMachinePanel.querySelectorAll('.knob');
        createSequencerGridUI(); // Create sequencer buttons and indicators

        await initAudio();

        if (isAudioInitialized) {
            updateAllKnobs(true);
            setupKnobListeners();
            setupSequencerListeners(); // Add listeners for sequencer controls
            setupGeneralInteractionListener(); // Listener to resume context
            console.log("JS Drum Synth Ready. Press A/S/D/F to play manually, Spacebar for sequencer.");
            if (audioContext?.state === 'suspended') {
                console.warn("REMINDER: Click panel or press key/space to enable audio.");
            }
        } else {
            console.error("Drum Synth initialization failed.");
        }
    });

</script>
</body>
</html>